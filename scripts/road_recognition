#!/usr/bin/env python
#     _/    _/                                _/                _/      _/
#    _/  _/      _/_/_/  _/      _/      _/      _/_/_/        _/_/    _/
#   _/_/      _/    _/  _/      _/      _/  _/  _/    _/      _/  _/  _/
#  _/  _/    _/    _/    _/  _/  _/  _/    _/  _/    _/      _/    _/_/
# _/    _/    _/_/_/      _/      _/      _/  _/    _/      _/      _/
# Supposed to display a transformed image from the camera, using the
# recognize_road function.

import rospy
from cv_bridge import CvBridge, CvBridgeError
import cv2
from sensor_msgs.msg import Image
import numpy as np


class road_recognition:
    def __init__(self):
        self.image = rospy.Subscriber(
            '/camera/image_raw', Image, self.callback, queue_size=10)
        self.bridge = CvBridge()

    def recognize_road(self, img):
        img = img[300:964, :]  # Cut out the sky
        filters = []
        # Combine different texture rotations
        # for theta in np.arange(-np.pi / 4, np.pi / 4, np.pi / 16):
        #     kern = cv2.getGaborKernel(
        #         (31, 31), 4, theta, 10.0, 0.1, 0.5, ktype=cv2.CV_32F)
        #     kern /= 1.5 * kern.sum()
        #     filters.append(kern)
        # accum = np.zeros_like(img)
        # for kern in filters:
        #     fimg = cv2.filter2D(img, cv2.CV_8UC3, kern)
        #     np.maximum(accum, fimg, accum)
        # accum = accum
        # equ = img
        for theta in np.arange(np.pi/4,3 * np.pi/4, np.pi / 16):
            kern = cv2.getGaborKernel(
                (31, 31), 4, theta, 10.0, 0.1, 0.1, ktype=cv2.CV_32F)
            kern /= 1.5 * kern.sum()
            filters.append(kern)
        accum = np.zeros_like(img)
        for kern in filters:
            fimg = cv2.filter2D(img, cv2.CV_8UC3, kern)
            np.maximum(accum, fimg, accum)
        accum = cv2.equalizeHist(accum)
        accum = cv2.GaussianBlur(accum, (5, 5), 0)
        # blurred = cv2.bilateralFilter(accum, 9, 75, 75)
        # accum = cv2.equalizeHist(accum)

        # blurred = cv2.medianBlur(equ, 11)
        # edges = cv2.Canny(blurred, 00,100)
        # lines = cv2.HoughLinesP(blurred, 1, np.pi / 180,
        #                         100, 100, 10)
        # for x1, y1, x2, y2 in lines[0]:
        #     cv2.line(blurred, (x1, y1), (x2, y2), (0, 255, 0), 2)
        return accum

    def callback(self, data):
        try:
            cv_image = self.bridge.imgmsg_to_cv2(data, 'mono8')
        except CvBridgeError as e:
            print(e)

        cv2.imshow('Image window', self.recognize_road(cv_image))
        cv2.waitKey(1)


def main():
    road_recognition()
    rospy.init_node('road_recognition', anonymous=True)
    try:
        rospy.spin()
    except KeyboardInterrupt:
        print('Shutting down')


if __name__ == '__main__':
    main()
